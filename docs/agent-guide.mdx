---
title: "Agent Setup Guide"
description: "A comprehensive guide for setting up AI agents with Relace, covering everything from basic concepts to advanced implementation."
---

## What are AI Agents?

AI agents are autonomous systems that can understand requests, make decisions, and take actions to complete tasks. Unlike simple workflows that follow predefined steps, agents can dynamically explore codebases, make iterative changes, and adapt their approach based on the context they discover.

Think of an agent as an AI developer that can:

- Navigate and understand your codebase
- Make educated decisions about what files to examine
- Execute a sequence of tools to complete complex tasks
- Learn from feedback and adjust their approach

## Agents vs Workflows

Understanding the difference between agents and workflows is crucial for choosing the right approach:

### Workflows

- **Structure**: Hand-crafted prompts with predefined steps
- **Speed**: Fast execution (typically 2-5 seconds)
- **Cost**: Lower cost due to efficient token usage
- **Flexibility**: Limited to predefined scenarios
- **Best for**: Repetitive tasks, prompt-to-app products, high-frequency operations

### Agents

- **Structure**: Autonomous tool-calling systems
- **Speed**: Slower execution (typically 10-60 seconds)
- **Cost**: Higher cost due to exploration and iteration
- **Flexibility**: Highly adaptable to complex, novel scenarios
- **Best for**: Complex coding tasks, exploratory work, handling edge cases

## Source Control Integration

Before setting up agents, ensure your source control is properly configured:

### Repository Structure

```
your-project/
├── .git/
├── src/
│   ├── components/
│   ├── utils/
│   └── services/
├── tests/
├── docs/
└── package.json
```

### Essential Files for Agents

- **README.md**: Helps agents understand project purpose and setup
- **package.json/requirements.txt**: Dependencies and scripts
- **.gitignore**: Prevents agents from viewing irrelevant files
- **tsconfig.json/pyproject.toml**: Language-specific configuration

### Git Best Practices

1. **Branching Strategy**: Create feature branches for agent work

   ```bash
   git checkout -b agent/feature-implementation
   ```

2. **Commit Messages**: Use clear, descriptive commits

   ```bash
   git commit -m "feat: add user authentication with JWT tokens"
   ```

3. **File Organization**: Keep related files together to help agents navigate

## Available Models

Relace provides specialized models optimized for different aspects of agent workflows:

### Instant Apply Model

- **Purpose**: High-speed code merging and editing
- **Speed**: ~10,000 tokens/second
- **Strength**: Precise code integration with minimal errors
- **Use Case**: Final step in agent workflows for applying changes

### Code Reranker

- **Purpose**: Relevance assessment of code files
- **Speed**: 1-2 seconds for full codebase analysis
- **Strength**: Identifies most relevant files for a given query
- **Use Case**: First step in agent workflows for context gathering

### Embedding Model

- **Purpose**: Semantic similarity and code comparison
- **Strength**: Understanding code relationships and dependencies
- **Use Case**: Advanced agent workflows requiring code analysis

### External Model Integration

Agents typically use frontier models for reasoning:

- **Claude 3.5 Sonnet**: Excellent for complex reasoning and code understanding
- **GPT-4**: Strong general-purpose capabilities
- **GPT-4o-mini**: Cost-effective option for simpler tasks

## Tool Definitions

Tools are the building blocks that give agents their capabilities. Here are essential tools for code agents:

### File Operations

```json
{
  "name": "semantic_merge_editor",
  "description": "Primary editing tool using Relace's Instant Apply",
  "parameters": {
    "command": ["view", "create", "edit"],
    "path": "string",
    "semantic_edit_snippet": "string"
  }
}
```

### Code Analysis

```json
{
  "name": "code_search",
  "description": "Search codebase for patterns and symbols",
  "parameters": {
    "query": "string",
    "file_types": "array",
    "include_context": "boolean"
  }
}
```

### Execution Tools

```json
{
  "name": "run_tests",
  "description": "Execute test suites and validate changes",
  "parameters": {
    "test_path": "string",
    "verbose": "boolean"
  }
}
```

### Version Control

```json
{
  "name": "git_operations",
  "description": "Git commands for branch management",
  "parameters": {
    "command": ["status", "diff", "commit", "push"],
    "message": "string"
  }
}
```

## Getting Started

### 1. Environment Setup

First, ensure your development environment is agent-ready:

```bash
# Install dependencies
npm install # or pip install -r requirements.txt

# Set up environment variables
export RELACE_API_KEY="your_api_key_here"
export GITHUB_TOKEN="your_github_token" # if using GitHub integration
```

### 2. Basic Agent Configuration

Create a configuration file for your agent:

```json
{
  "agent_config": {
    "name": "code_assistant",
    "model": "claude-3-5-sonnet",
    "tools": ["semantic_merge_editor", "code_search", "run_tests"],
    "max_iterations": 10,
    "temperature": 0.1
  },
  "relace_config": {
    "api_key": "${RELACE_API_KEY}",
    "models": {
      "instant_apply": "relace/instant-apply-v1",
      "reranker": "relace/code-reranker-v2"
    }
  }
}
```

### 3. Your First Agent

Here's a simple agent implementation:

```python
import asyncio
from relace import InstantApply, CodeReranker

class CodeAgent:
    def __init__(self, config):
        self.instant_apply = InstantApply(api_key=config["relace_api_key"])
        self.reranker = CodeReranker(api_key=config["relace_api_key"])

    async def process_request(self, request, codebase_path):
        # Step 1: Find relevant files
        relevant_files = await self.reranker.rank(
            query=request,
            files=self.get_all_files(codebase_path)
        )

        # Step 2: Generate edit snippet (using frontier model)
        context = self.load_files(relevant_files[:5])
        edit_snippet = await self.generate_edit(request, context)

        # Step 3: Apply changes with Instant Apply
        result = await self.instant_apply.apply(
            file_path=edit_snippet["target_file"],
            snippet=edit_snippet["content"]
        )

        return result
```

### 4. Advanced Agent Patterns

#### Multi-Step Reasoning

```python
class AdvancedAgent:
    async def complex_task(self, request):
        # Break down complex requests
        steps = await self.plan_steps(request)

        for step in steps:
            # Execute each step with validation
            result = await self.execute_step(step)
            if not self.validate_step(result):
                await self.correct_step(step, result)
```

#### Error Recovery

```python
def with_retry(max_attempts=3):
    async def wrapper(self, *args, **kwargs):
        for attempt in range(max_attempts):
            try:
                return await self.original_method(*args, **kwargs)
            except Exception as e:
                if attempt == max_attempts - 1:
                    raise
                await self.handle_error(e, attempt)
    return wrapper
```

## Best Practices

### Performance Optimization

1. **Use Reranker First**: Always start with code reranking to limit context
2. **Batch Operations**: Group related file operations together
3. **Cache Results**: Store frequently accessed code snippets
4. **Limit Iterations**: Set reasonable bounds on agent exploration

### Safety Measures

1. **Sandbox Testing**: Test changes in isolated environments
2. **Incremental Commits**: Make small, reversible changes
3. **Validation Steps**: Run tests after each significant change
4. **Human Oversight**: Implement approval gates for critical changes

### Code Quality

1. **Style Consistency**: Maintain existing code style and patterns
2. **Documentation**: Update comments and docs alongside code changes
3. **Test Coverage**: Ensure new code includes appropriate tests
4. **Dependency Management**: Carefully consider new dependencies

## Common Pitfalls

### Over-exploration

**Problem**: Agent spends too much time examining files
**Solution**: Use code reranker to pre-filter relevant files

### Context Overflow

**Problem**: Including too much code context leads to errors
**Solution**: Focus on minimal, targeted edits with clear boundaries

### Inconsistent Patterns

**Problem**: Agent creates code that doesn't match existing patterns
**Solution**: Include style guidelines and examples in system prompts

### Missing Error Handling

**Problem**: Agents don't gracefully handle edge cases
**Solution**: Implement comprehensive error recovery and validation

## Troubleshooting

### Common Issues

#### "File not found" errors

- Verify file paths are absolute and correct
- Check that files haven't been moved or deleted during execution

#### Merge conflicts

- Ensure edit snippets include sufficient context
- Use more specific boundary comments in snippets

#### Performance issues

- Profile agent execution to identify bottlenecks
- Consider switching from agent to workflow for repetitive tasks

#### Quality problems

- Review and improve system prompts
- Add more specific validation steps
- Include better examples in tool definitions

## Next Steps

1. **Start Simple**: Begin with basic file editing agents
2. **Iterate Gradually**: Add complexity as you learn what works
3. **Monitor Performance**: Track latency, cost, and quality metrics
4. **Join the Community**: Connect with other developers using Relace agents

For more specific implementations, check out our:

- [Workflow Guide](/docs/instant-apply/workflow) for hand-crafted prompt systems
- [API Reference](/api-reference/instant-apply/apply) for detailed integration docs
- [Agent Tool Definition](/docs/instant-apply/agent) for advanced tool configurations

Ready to build your first agent? [Try the playground](https://app.relace.ai/playground/instant-apply) to experiment with edit snippets and see Instant Apply in action.
